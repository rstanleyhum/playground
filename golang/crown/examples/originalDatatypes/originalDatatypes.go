package main

import (
	"encoding/csv"
	"errors"
	"fmt"
	"io"
	"log"
	"os"
	"sort"
	"strconv"
	"strings"
	"unicode"

	"github.com/iancoleman/strcase"
)

// Column holds a record from the CSV
type Column struct {
	ID                 int
	SchemaName         string
	ReferenceTableName string
	TableName          string
	ColumnName         string
	OrdinalPosition    int
	IsNullable         bool
	DataType           string
	ColumnDefault      string
}

// NewColumn creates a new Column variable
func NewColumn(record []string) (Column, error) {
	var c Column
	var i = -1
	var err error
	if record[0] != "" {
		i, err = strconv.Atoi(record[0])
		if err != nil {
			return Column{}, err
		}
	}
	c.ID = i
	c.SchemaName = record[1]
	c.ReferenceTableName = record[2]
	c.TableName = createTableName(c.ReferenceTableName)
	c.ColumnName = record[3]

	i, err = strconv.Atoi(record[4])
	if err != nil {
		return Column{}, err
	}
	c.OrdinalPosition = i

	c.IsNullable = false
	if record[5] == "YES" {
		c.IsNullable = true
	}
	c.DataType = record[6]
	c.ColumnDefault = record[7]
	return c, nil
}

func createTableName(tn string) string {
	return tn
}

// ByRec is a Sort by full Column
type ByRec []Column

func (a ByRec) Len() int      { return len(a) }
func (a ByRec) Swap(i, j int) { a[i], a[j] = a[j], a[i] }
func (a ByRec) Less(i, j int) bool {
	if !(a[i].SchemaName == a[j].SchemaName) {
		return a[i].SchemaName < a[j].SchemaName
	}
	if !(a[i].TableName == a[j].TableName) {
		return a[i].TableName < a[j].TableName
	}
	return a[i].OrdinalPosition < a[j].OrdinalPosition
}

func main() {
	filename := "<column filename>"
	r, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer r.Close()

	csvRead := csv.NewReader(r)

	file, err := os.Create("<tables filename>")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	recs := []Column{}

	_, err = csvRead.Read()
	if err != nil {
		log.Fatal(err)
	}

	for {
		record, err := csvRead.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatal(err)
		}

		rec, err := NewColumn(record)
		if err != nil {
			log.Fatal(err)
		}

		recs = append(recs, rec)
	}

	sort.Sort(ByRec(recs))

	printHeader(file)
	lastTable := ""
	for _, v := range recs {
		if v.TableName != lastTable {
			if lastTable != "" {
				printCloseTable(file)
			}
			printNewTable(file, v.SchemaName, v.TableName)
			lastTable = v.TableName
		}
		printVariable(file, v.ColumnName, v.IsNullable, v.DataType)
	}
	printCloseTable(file)
}

func printNewTable(f io.Writer, sn string, tn string) {
	csn, err := cleanName(sn)
	if err != nil {
		log.Fatal(err)
	}

	ctn, err := cleanName(tn)
	if err != nil {
		log.Fatal(err)
	}
	fullTn := fmt.Sprintf("%s%s", csn, ctn)
	fmt.Fprintf(f, "// %s represents a record in the %s.%s table in the replica\n", fullTn, sn, tn)
	fmt.Fprintf(f, "type %s struct {\n", fullTn)
}

func printCloseTable(f io.Writer) {
	fmt.Fprintf(f, "}\n")
	fmt.Fprintf(f, "\n")
}

func printHeader(f io.Writer) {
	fmt.Fprintf(f, "package table\n")
	fmt.Fprintf(f, "\n")
	fmt.Fprintf(f, "// This file is autogenerated.\n")
	fmt.Fprintf(f, "\n")
	fmt.Fprintf(f, "import (\n")
	fmt.Fprintf(f, "\t\"database/sql\"\n")
	fmt.Fprintf(f, "\t\"time\"\n")
	fmt.Fprintf(f, "\t\"_snippets/golang/crown/crownsql\"\n")
	fmt.Fprintf(f, ")\n")
	fmt.Fprintf(f, "\n")
}

func printVariable(f io.Writer, cn string, nullable bool, dt string) {
	coltype := getFullColumnDataType(nullable, dt)
	ccn, err := cleanName(cn)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Fprintf(f, "\t%s %s `db:\"%s\"`\n", ccn, coltype, cn)
}

func getFullColumnDataType(nullable bool, dt string) string {
	if nullable {
		return fmt.Sprintf("nullable-%s", dt)
	}
	return dt
}

func getNullColumnDataType(dt string) string {
	switch dt {
	case "decimal":
		return "sql.NullFloat64"
	case "nvarchar":
		return "sql.NullString"
	case "char":
		return "sql.NullString"
	case "varchar":
		return "sql.NullString"
	case "text":
		return "sql.NullString"
	case "datetime":
		return "crownsql.NullDatetime"
	case "numeric":
		return "sql.NullInt64"
	case "int":
		return "sql.NullInt64"
	case "smallint":
		return "sql.NullInt64"
	case "float":
		return "sql.NullFloat64"
	case "bit":
		return "sql.NullInt64"
	case "uniqueidentifier":
		return "crownsql.NullUniqueID"
	case "tinyint":
		return "sql.NullInt64"
	case "real":
		return "sql.NullFloat64"
	case "smallmoney":
		return "sql.NullFloat64"
	case "bigint":
		return "sql.NullInt64"
	case "date":
		return "crownsql.NullDatetime"
	case "xml":
		return "sql.NullString"
	case "varbinary":
		return "crownsql.NullVarbinary"
	case "smalldatetime":
		return "crownsql.NullDatetime"
	case "timestamp":
		return "crownsql.NullDatetime"
	case "money":
		return "sql.NullFloat64"
	case "image":
		return "crownsql.NullVarbinary"
	case "nchar":
		return "sql.NullString"
	}
	return fmt.Sprintf("sql.NULLERROR-%s", dt)
}

func getColumnDataType(dt string) string {
	switch dt {
	case "decimal":
		return "float64"
	case "nvarchar":
		return "string"
	case "char":
		return "string"
	case "varchar":
		return "string"
	case "text":
		return "string"
	case "datetime":
		return "time.Time"
	case "numeric":
		return "int"
	case "int":
		return "int"
	case "smallint":
		return "int"
	case "float":
		return "float64"
	case "bit":
		return "int"
	case "uniqueidentifier":
		return "crownsql.UniqueID"
	case "tinyint":
		return "int"
	case "real":
		return "float64"
	case "smallmoney":
		return "float64"
	case "bigint":
		return "int"
	case "date":
		return "time.Time"
	case "xml":
		return "string"
	case "varbinary":
		return "[]byte"
	case "smalldatetime":
		return "time.Time"
	case "timestamp":
		return "time.Time"
	case "money":
		return "float64"
	case "image":
		return "[]byte"
	case "nchar":
		return "string"
	}
	return fmt.Sprintf("sql.ERROR-%s", dt)
}

func removeSpaces(s string) string {
	a := strings.Replace(s, " ", "", -1)
	b := strings.Replace(a, "(", "", -1)
	c := strings.Replace(b, ")", "", -1)
	d := strings.Replace(c, "/", "", -1)
	return d
}

func cleanName(s string) (string, error) {
	tmp := removeSpaces(s)

	if tmp == "" {
		return "", errors.New("no name to convert")
	}

	tmp = strcase.ToCamel(tmp)

	first := []rune(tmp)[0]
	if !unicode.IsLetter(first) {
		tmp = fmt.Sprintf("A%s", tmp)
	}

	if tmp == "Ip" {
		return "IP", nil
	}
	if tmp == "Id" {
		return "ID", nil
	}

	if len(tmp) < 3 {
		return tmp, nil
	}

	r2 := []rune(tmp)
	last := len(r2) - 1
	if (unicode.ToLower(r2[last-1]) == 'i') && (unicode.ToLower(r2[last]) == 'd') {
		r2[last-1] = 'I'
		r2[last] = 'D'
		tmp = string(r2)
	}

	tmp = strings.Replace(tmp, "Uri", "URI", -1)
	tmp = strings.Replace(tmp, "Xml", "XML", -1)
	tmp = strings.Replace(tmp, "Url", "URL", -1)
	tmp = strings.Replace(tmp, "Sql", "SQL", -1)
	tmp = strings.Replace(tmp, "Html", "HTML", -1)
	tmp = strings.Replace(tmp, "HistoryId", "HistoryID", -1)
	return tmp, nil
}
